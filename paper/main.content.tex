\chapter{Uvod}\label{cahp:uvod}
S problemi velikih dimenzij sem med drugim srečujemo na različnih področjih, kot so telekomunikacije, logistika, strojništvo itd.
Ti problemi zahtevajo iskanje optimalnih rešitev v obsežnem iskalnem prostoru, kjer ima problem veliko število odločitvenih spremenljivk.
Pri takih problemih tradicionalni optimizacijski algoritmi, kot so to metode, ki temeljijo na gradientu, kvadratno programiranje in linearno programiranje, se soočajo s težavami.
Inteligenca rojev (ang. \textit{Swarm inteligence} (SI)) se je pojavila, kot obetaven pristop za reševanje problemov velikih dimenzij zaradi svoje zmožnosti učinkovitega raziskovanja prostora, obvladovanja šumnih in ne-konveksnih cenitvenih funkcij, ter obvladovanja velikega števila parametrov objektivne funkcije.

Inteligenca rojev se nanaša na kolektivno vedenje decentraliziranih, samoorganiziranjih sistemov, sestavljenih iz več agentov, ki sodelujejo med seboj in v okolju, da bi dosegli skupni cilj.
Agenti v sistemih SI so lahko umetni ali naravni, komunicirajo in usklajujejo pa se po preprostih lokalnih pravilih.
Vedenje teh agentov se zgleduje po vedenju družbenih žuželk, kot so mravlje, čebele in termiti, ki v svojih kolonijah kažejo izjemne sposobnosti reševanja problemov.

Eden najbolj priljubljenih SI algoritmov za reševanje problemov velikih dimenzij je algoritem roja delcev (ang. \textit{Particle Swarm Optimization} (PSO))~\cite{alg:pso}.
PSO algoritem sta prvič predlagala Ebarhart in Kennedy leta 1995 in je od takrat pridobil široko pozornost zaradi svoje preprostosti, robustnosti in učinkovitosti.
PSO algoritem deluje tako, da simulira vedenje skupine delcev, ki se premikajo v iskalnem prostoru, da bi našli optimalno rešitev.
Vsak delec predstavlja kandidatno rešitev problema, njegovo gibanje pa je odvisno od njegove lastne hitrosti in najboljše rešitve, ki jo je skupina delcev doslej našla.

Druga algoritma rojev delcev, ki je sta lahko uporabljen za optimizacijo velikih dimenzij sta algoritem optimizacije kolonije mravelj (ang. \textit{Ant Colony Optimization} (ACO))~\cite{alg:aco} pri iskanju hrane in algoritem umetne čebelje kolonije (ang. \textit{Artificial Bee Colony} (ABC))~\cite{alg:abc}, ki posnema vedenje iskanja hrane čebel.
ACO algoritem deluje tako, da zgradi graf rešitve, ki predstavlja prostor iskanja, mravlje se premikajo po tem grafu, kjer preiskujejo prostor in iščejo nove boljše rešitve problema.
ABC algoritem zaposluje skupino čebel, ki iščejo iskalni prostor za vire hrane, pri čemer vsaka čebela predstavlja kandidatno rešitev problema.

Glavna prednost uporabe SI algoritmov za optimizacijo problemov velikih dimenzij je njihova sposobnost obvladovanja kompleksnosti in velike dimenzionalnosti iskalnega prostora.
Tradicionalni optimizacijski algoritmi se soočajo s težavami pri reševanju takih problemov zaradi visokih računskih stroškov in prisotnosti večih lokalnih optimumov.
Nasprotno pa SI algoritmi uporabljajo preprosta lokalna pravila za učinkovito raziskovanje iskalnega prostora in so odpornejši na lokalne optimume, v katerih lahko obtičijo mnogi tradicionalni algoritmi.

Uporabo SI algoritmov za optimizacijo problemov velikih dimenzij, lahko opazimo na mnogih področjih, kot so strojništvo, finance in logistika.
V strojništvu so bili SI algoritmi uporabljeni za optimizacijo kompleksnih sistemov, kot so letala, turbine in motorji.
V finančnem sektorju so bili SI algoritmi uporabljeni za optimizacijo portfelja in obvladovanje tvegan podjetji.
V logistiki so bili SI algoritmi uporabljeni za optimizacijo usmerjanja vozil, upravljanja s skladiščem in optimizacije dobavne verige.
SI algoritmi so se izkazali za zelo učinkovite in njihov uspeh je spodbudil nadaljnje raziskave razvoja novih in izboljšanih algoritmov.

Kljub prednostim SI algoritmov imajo tudi ti algoritmi nekatere omejitve, kot so počasna stopnja konvergence, potreba po velikem številu ovrednotenj cenitvene funkcije in občutljivosti na nastavitve parametrov algoritma.
Za premagovanje teh omejitev so raziskovali predlagali več modifikacij in hibridizacij SI algoritmov, kot je hibridizacija z lokalnimi iskalnimi metodami, operatorji mutacije in hibridizacija z drugimi optimizacijskimi algoritmi.

V zadnjih letih so raziskovalci uvedli koncept diferencialnega združevanja in koevolucije kot nove strategije za izboljšanje učinkovitosti optimizacijskih algoritmov za reševanje problemov velikih dimenzij.
Cilj teh strategij je izboljšati proces iskanja z razdelitvijo optimizacijskega problema na manjše podprobleme in sočasno uporabo optimizacijskih algoritmov za optimizacijo vsakega podproblema.
Podproblemi se nato uskladijo z diferencialnim združevanjem in koevoluciskimi mehanizmi, na način da vodijo celoten proces iskanja k boljšim rešitvam.

Koevolucija je tehnika, ki podpira reševanje hkraten razvoj večih populacij, ki rešujejo svoj podproblem.
Podproblemi medsebojno delujejo in vplivajo na razvoj drug drugega, ter ustvarjajo dinamično in konkurenčno okolje.
Koevolucija spodbuja raziskovanje različnih regij iskalnega prostora in spodbuja izmenjavo informacij med podproblemi.
Ta kooperativna interakcija med podproblemi lahko vodi do odkritja boljših rešitev in izboljšanja konvergentnih lastnosti.

Kombinacija diferencialnega združevanja in koevelucije za hribidizacijo optimizacijskih algoritmov je pokazala obetavne rezultate pri reševanju problemov velikih dimenzij.
Te strategije izkoriščajo prednosti obeh tehnik, kar omogoča učinkovito raziskovanje in izkoriščanje iskalnega prostora.
Z razčlenitvijo problema na manjše podprobleme in uporabo optimizacijskih algoritmov postane proces iskanja bolj osredotočen in učinkovit.

Motivacija za to diplomsko delo izhaja iz potrebe po obravnavanju naraščajočega povpraševanja po učinkovitih in uspešnih rešitvah problemov velikih dimenzij.
S pojavom vele podatkov (ang. \textit{Big Data}) in vse večjo kompleksnostjo sodobnih sistemov, tradicionalne optimizacijske tehnike ne zadoščajo za pravočasno zagotavljanje optimalnih rešitve.
PSO algoritmi ponujajo obetavno alternativo za reševanje teh zahtevnih problemov, vendar so potrebne nadaljnje raziskav, da bi v celoti razumeli njihove zmogljivosti in omejitve.

V tem diplomskem delu želimo raziskati učinkovitost kovelucijskega hibridnega PSO algoritma z rekurzivnimi diferencialnimi metodami grupiranja za reševanje problemov velikih dimenzij.
Raziskali bomo, kako lahko te strategije izboljšajo delovanje PSO algoritmov.
Z obsežnim eksperimentiranjem in primerjalno analizo bomo ovrednotili delovanje predlaganega algoritma v primerjavi z obstoječimi hibridnimi PSO algoritmi.
S preučevanjem njegove hitrosti konvergence, kakovosti rešitev in robustnosti želimo zagotoviti vpogled v potencialne prednosti in omejitve novega hibridnega algoritma v kontekstu problemov velikih dimenzij.
Z vključitvijo konceptov diferencialnega grupiranja in koevolucije v hibridne PSO algoritme pričakujemo, da bomo premagali nekatere omejitve in izzive, ki jih predstavljajo optimizacijski problemi velikih dimenzij.
Te strategije imajo potencial za izboljšanje zmožnosti raziskovanja in izkoriščanja optimizacijskih algoritmov,  kar vodi do učinkovitejših in uspešnejših rešitev.
Preiskava teh tehnik v kontekstu problemov veliki dimenzij je ključnega pomena za napredek na področju optimizacijskih algoritmov iz zagotavljanja praktičnih rešitev za aplikacije v resničnem svetu.

Prispevki tega diplomskega dela naj bi vključevali:
\begin{enumerate}
    \item Obsežen pregled literature o PSO algoritmih, vključno zz analizo prednosti in omejitev različnih PSO algoritmov.
    \item Vrednotenje delovanja različnih PSO algoritmov na problemih velikih dimenzij, ki vključujejo multimudalne funkcije, popolnoma odvedljive funkcije, delno aditivno odvedljive funkcije, funkcije s prekrivajočimi komponentami in ne-odvedljive funkcije.
    \item Raziskovanje vpliva različnih uporabljenih metod hibridizacije PSO algoritma na problemih velikih dimenzij.
    \item Priporočila za izbiro in nastavitve hibridiziranih PSO algoritmov za probleme velikih dimenzij, ki temeljijo na rezultatih naših poskusov.
\end{enumerate}

Preostanek tega diplomskega dela je organiziran na naslednji način.
V \ref{chap:obsojeca.dela}. poglavju ponujamo pregled literature o optimizacijskih algoritmih inteligence rojev za optimizacijo problemov velikih dimenzij.
To poglavje vključuje podrobno razpravo o prednostih in omejitvah različnih optimizacijskih algoritmov inteligence rojev, algoritmov grupiranja komponent, ki bazirajo na razlikah vpliva komponent, ter koevolucijskih algoritmih za reševanje problemov velikih dimenzij.
V \ref{chap:algo}. poglavju opisujemo novo hibidizacijo PSO algoritma, ki uporablja koevolucijo in grupiranje komponent za probleme velikih dimenzij.
To poglavje vključuje razpravo o uporabljenih metodah za modifikacijo hibridnega PSO algoritma, ter omejitvah novega hibridnega algoritma.
Poglavje vsebuje tudi priporočila za izbiro, nastavitev parametrov in omejitve hibridnih PSO algoritmov za probleme velikih dimenzij.
V \ref{chap:exp}. poglavju posredujemo rezultate naših poskusov in razpravljamo o uspešnosti različnih hibridnih PSO algoritmih na problemih velikih dimenzij.
To poglavje vključuje podrobno analizo vpliva različnih parametrov hibridnih PSO algoritmov.
Na koncu \ref{chap:end}. poglavju podajamo povzetek naših ugotovitev, zaključkom in predlogi za prihodnje raziskave na tem področju. Verjamemo, da bo ta diplomska naloga zagotovila dragocen vpogled v uporabo SI algoritmov za optimizacijo problemov velikih dimenzij in prispevala k razvoju učinkovitejših in uspešnejših optimizacijskih tehnik.

\chapter{Pregled obstoječih del}\label{chap:obsojeca.dela}

Razširljivost optimizacijskih algoritmov je velik izziv pri spopadanju z vedno večjim obsegom optimizacijskih problemov na številnih področjih uporabe od visokodimenzionalnega strojnega učenja do kompleksnih obsežnih inženirskih problemov.
Področje obsežne globalne optimizacije se ukvarja z izboljšanjem razširljivosti globalnih optimizacijskih algoritmov, zlasti metahevristik, ki temeljijo na populaciji.
Takšna metahevristika je bila uspešno uporabljena za zvezne, diskretne ali kombinatorne probleme, ki segajo od več tisoč do milijarde odločitev spremenljivk.
V tej raziskavi pregledujemo nedavne študije na področju obsežne globalne optimizacije (LSGO) črne skrinjice, da bi raziskovalcem in izvajalcem pomagali pridobiti pogled na to področje iz ptičje perspektive, se seznaniti z njegovimi glavnimi trendi in stanjem najsodobnejši algoritmi.
Štirje glavni algoritemski pristopi za reševanje problemov LSGO so:
\begin{enumerate}
	\item razčlenitev problema,
	\item populacijski algoritmi,
	\item memetične algoritme in
	\item metode lokalnega iskanja.
\end{enumerate}
V nadaljevanju sledijo opisi algoritemskih pristopov k obsežno globalno optimizacijo, opisuje širok spekter problemskih področij in se končno dotakne pasti in izzivov trenutnih raziskav ter identificira več potencialnih področij za prihodnje raziskave.

Prekletstvo dimenzionalnosti od najzgodnejših časov je »dnevi prekletstva, ki je pestilo znanstvenike od najzgodnejših dni«, krotenje pa je bilo v središču številnih raziskovalnih prizadevanj v računalniških znanostih, od računalniške linearne algebre in strojnega učenja do numerične optimizacije.
Motiv na vseh teh področjih je oblikovati nove načine za izgradnjo razširljivih računalniških sistemov, ki so sposobni "narediti več z manj".
V kontekstu numerične optimizacije je prekletstvo dimenzionalnosti posledica eksponentne rasti velikosti iskalnega prostora glede na povečanje števila vhodnih spremenljivk.
V zadnjih letih se to ohlapno imenuje "veliko- optimizacija obsega« ali »globalna optimizacija velikega obsega«.
Izraz globalno poudarja vlogo hevristike in metahevristike, zlasti v kontekstu nenehne optimizacije.
Treba je opozoriti, da se pojem "velikega obsega" spreminja skozi čas in se razlikuje od problema do problema.
V tem članku je problem se šteje za velik, če povzroča težave z razširljivostjo na najsodobnejših algoritmih.
Natančneje, posamezen problem ciljne optimizacije je mogoče definirati na naslednji način (ob predpostavki minimizacije):
\begin{align}
	\min&{f(\mathbf{x})} \label{eq:min_opt}\\
	\mathbf{g}(\mathbf{x}) &\leq 0 \label{eq:min_opt_inequ}\\
	\mathbf{h}(\mathbf{x}) &= 0 \label{eq:min_opt_equ}\\
	\mathbf{x} &= (x_1, \cdots, x_n) \in \Omega \label{eq:min_opt_space},
\end{align}
kjer $\Omega$ predstavlja celotni iskalni prostor, ter $\mathbf{x}$ predstavlja točko znotraj $\Omega$ iskalnega prostora.
Funkcija $f$ predstavlja cenitveno funkcijo, ki jo minimiziramo, kar predstavlja enačba~\ref{eq:min_opt}.
Funkciji $\mathbf{g}$ in $\mathbf{h}$ predstavljata omejitve, ki jih lahko problem ima.
Funkcija $\mathbf{g}$ predstavlja neenakosti, ki so predstavljene kot $\mathbf{g}(\mathbf{x}) = (g_1(\mathbf{x}), \cdots, g_p(\mathbf{x}))$, ter imamo $p$ neenakosti, ki jih moramo upoštevati.
Funkcija $\mathbf{h}$ predstavlja enakosti, ki so predstavljene kot $\mathbf{h}(\mathbf{x}) = (h_1(\mathbf{x}), \cdots, h_q(\mathbf{x}))$, ter imamo $q$ enakosti, ki jih mora rešitev upoštevati.
Neenakostim zadovoljimo tako da s podano rešitvijo izpolnimo pogoj podan v enačbi~\ref{eq:min_opt_inequ}.
Enakosti pa zadovoljimo, ko izpolnimo pogoj iz enačbe~\ref{eq:min_opt_equ}.

% TODO nekaj še tu dopiši

\section{Optimizacijski algoritmi in inteligenca rojev}

% TODO Napiši nekaj o Populacijskih algoritmih in inteligenci rojev

\section{Roj delcev}

% TODO Opiši uporabljene algoritme v svojem delu

\section{Koevolucija}

% TODO Opiši kaj je to Koevolucija

\section{Diferencialne metode grupiranja}

% TODO Opiši kaj je to metoda grupiranja

\begin{algorithm}
    \DontPrintSemicolon
    \KwIn{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\alpha$, $k$}
    \SetKwFunction{Inter}{Interact}
    \SetKwFunction{app}{Pripni}

    $\mathbf{x}_r$, $\mathbf{a}$, $\mathbf{G}$ \gets~ [1], [], []\;
    $\epsilon$ \gets~ $\alpha \cdot \min(|f(\mathbf{x}_1)|, \cdots, |f(\mathbf{x}_k)|)$\;
    $\mathbf{x}_{l,l}$, $y_{l,l}$ \gets~ $\mathbf{b}_{\downdownarrows}$, $f(\mathbf{b}_{\downdownarrows})$\;
    $\mathbf{s}_1$, $\mathbf{s}_2$ \gets~ [1], [\lFor*{$i=2$ \KwTo \ell($\mathbf{b}_{\downdownarrows}$)}{$i$}]\;

    \While{\ell($\mathbf{x}_r$) > 0}{
        $\mathbf{x}_r$ \gets~ []\;
        $\mathbf{s}^*$ \gets~ \Inter{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $y_{l,l}$, $\epsilon$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\mathbf{x}_r$}\tcp*[f]{Algoritem~\ref{pcode:rdg:interact}}\;
        \eIf{\ell($\mathbf{s}^*$) $=$ \ell($\mathbf{s}_1$)}{
            \leIf{\ell($\mathbf{s}_1$) $=$ $1$}{$\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$}{\app{$\mathbf{G}$, $\mathbf{s}_1$}}
            \eIf{\ell(\app{$\mathbf{x}_r$} > $1$)}{
                $\mathbf{s}_1$ \gets~ $\mathbf{x}_r$[:1]\;
                $\mathbf{x}_r$ \gets~ $\mathbf{x}_r$[1:]\;
                $\mathbf{s}_2$ = $\mathbf{x}_r$\;
            }{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$\;
                \textbf{break}\;
            }
        }{
            $\mathbf{s}_1$ \gets~ $\mathbf{s}^*$\;
            $\mathbf{s}_2$ \gets~ $\mathbf{x}_r$\;
            \If{\ell($\mathbf{s}_r$) = $0$}{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
                \textbf{break}\;
            }
        }
    }
    \lForEach{$e$ in $\mathbf{a}$}{\app{$\mathbf{G}$, $[e]$}}
    \Return $\mathbf{G}$

    \caption{Algoritem RDG~\cite{alg:rdg} za dekompozicijo problema.}
    \label{pcode:rdg}
\end{algorithm}

\begin{algorithm}
    \DontPrintSemicolon
	\KwIn{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $y_{l,l}$, $\epsilon$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\mathbf{x}_r$}
	\SetKwFunction{Inter}{Interact}
    \SetKwFunction{floor}{floor}

    $\mathbf{x}_{u,l}$, $\mathbf{x}_{l,m}$ \gets~ $\mathbf{x}_{l,l}$, $\mathbf{x}_{l,l}$\;
    $\mathbf{x}_{u,m}$, $\mathbf{x}_{u,l}$ \gets~ $\mathbf{b}_{\upuparrows}$[$\mathbf{s}_1$], $\mathbf{b}_{\upuparrows}$[$\mathbf{s}_2$]\;
    $\mathbf{x}_n$ \gets~ $\mathbf{s}_1$\;
    $\mathbf{x}_{l,m}$, $\mathbf{x}_{u,m}$ \gets~ $\frac{\mathbf{b}_{\downdownarrows} + \mathbf{b}_{\upuparrows}}{2}$[$\mathbf{s}_2$], $\frac{\mathbf{b}_{\downdownarrows} + \mathbf{b}_{\upuparrows}}{2}$[$\mathbf{s}_2$]\;
    $y_{u,l}$, $y_{l,m}$, $y_{u,m}$ \gets~ $f(\mathbf{x}_{u,l})$, $f(\mathbf{x}_{l,m})$, $f(\mathbf{x}_{u,m})$\;
    $\sigma_1$, $\sigma_2$ \gets~ $y_{l,l} - y_{u,l}$, $y_{l,m} - y_{u,m}$\;

    \eIf{$|\sigma_1 - \sigma_2| > \epsilon$}{ \label{pcode:inter:test}
        \eIf{\ell($\mathbf{s}_2$) $=$ $1$}{
            $\mathbf{x}_n$ \gets~ $\mathbf{s}_1 \cup \mathbf{s}_2$\;
        }{
            $k$ \gets~ \floor{\ell($\mathbf{s}_2$) / 2}\;
            $\mathbf{g}_1$, $\mathbf{g}_2$ \gets~ $\mathbf{s}_2$[:$k$], $\mathbf{s}_2$[$k$:]\;
            $\mathbf{x}_1$ \gets~ \Inter{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $y_{l,l}$, $\epsilon$, $\mathbf{s}_1$, $\mathbf{g}_1$, $\mathbf{x}_r$}\tcp*[f]{Algoritem~\ref{pcode:rdg:interact}}\;
            $\mathbf{x}_2$ \gets~ \Inter{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $y_{l,l}$, $\epsilon$, $\mathbf{s}_1$, $\mathbf{g}_2$, $\mathbf{x}_r$}\tcp*[f]{Algoritem~\ref{pcode:rdg:interact}}\;
            $\mathbf{x}_n$ \gets~ $\mathbf{x}_1 \cup \mathbf{x}_2$\;
        }
    }{
        $\mathbf{x}_r$ \gets~ $\mathbf{x}_r \cup \mathbf{s}_2$
    }
    \Return $\mathbf{x}_n$
 
	\caption{Funkcija \texttt{Interact} za detekcijo interakcije med komponentami pri algoritmu RDG.}
	\label{pcode:rdg:interact}
\end{algorithm}

% TODO opiši algoritem RDG

\begin{equation}\label{eq:rdg2:epsilon}
    \epsilon = \frac{(y_{l,l} + y_{u,l} + y_{l,m} + y_{u,m}) \cdot (\sqrt{D} + 2) \cdot \frac{\alpha}{2}}{1 - (y_{l,l} + y_{u,l} + y_{l,m} + y_{u,m}) \cdot (\sqrt{D} + 2) \cdot \frac{\alpha}{2}}
\end{equation}

% TODO opiši algoritem RDG2, tukja predvsem kaj se spremeni napram prejšnjem
% TODO dodaj primerjavo med RDG--RDG2

\begin{algorithm}
    \DontPrintSemicolon
    \KwIn{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\alpha$, $\epsilon_n$, $\epsilon_s$}
    \SetKwFunction{Inter}{Interact}
    \SetKwFunction{app}{Pripni}

    $\mathbf{x}_r$, $\mathbf{a}$, $\mathbf{G}$ \gets~ [1], [], []\;
    $\mathbf{x}_{l,l}$, $y_{l,l}$ \gets~ $\mathbf{b}_{\downdownarrows}$, $f(\mathbf{b}_{\downdownarrows})$\;
    $\mathbf{s}_1$, $\mathbf{s}_2$ \gets~ [1], [\lFor*{$i=2$ \KwTo \ell($\mathbf{b}_{\downdownarrows}$)}{$i$}]\;

    \While{\ell($\mathbf{x}_r$) $>$ $0$}{
        $\mathbf{x}_r$ \gets~ []\;
        $\mathbf{s}^*$ \gets~ \Inter{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $y_{l,l}$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\mathbf{x}_r$}\tcp*[f]{Algoritem~\ref{pcode:rdg:interact}}\;
        \eIf{\ell($\mathbf{s}^*$) $\neq$ \ell($\mathbf{s}_1$) $\land$ \ell($\mathbf{s}^*$) $<$ $\epsilon_n$}{
            $\mathbf{s}_1$, $\mathbf{s}_2$ \gets~ $\mathbf{s}^*$, $\mathbf{x}_r$\;
            \If{\ell($\mathbf{x}_r$) $=$ $0$}{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
                \textbf{break}\;
            }
        }{
            \eIf{\ell($\mathbf{s}^*$) $\neq$ $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$
            }{
                \app{$\mathbf{G}$, $\mathbf{s}^*$}
            }
            \uIf{\ell($\mathbf{x}_r$) $>$ $1$}{
                $\mathbf{s}_1$ \gets~ $\mathbf{x}_r$[:$1$]\;
                $\mathbf{x}_r$ \gets~ $\mathbf{x}_r$[$1$:]\;
                $\mathbf{s}_2$ \gets~ $\mathbf{x}_r$\;
            }
            \ElseIf{\ell($\mathbf{x}_r$) $=$ $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{x}_r$\;
                \textbf{break}\;
            }
        }
    }
    \While{\ell($\mathbf{a}$) $>$ $\epsilon_s$}{
        \app{$\mathbf{G}$, $\mathbf{a}$[:$\epsilon_s$]}\;
        $\mathbf{a}$ \gets~ $\mathbf{a}$[$\epsilon_s$:]\;
    }
    \lIf{\ell($\mathbf{a}$) $>$ $0$}{
        \app{$\mathbf{G}$, $\mathbf{a}$}
    }
    \Return $\mathbf{G}$\;

    \caption{Algoritem RDG3~\cite{alg:rdg3} za dekompozicijo problema.}
    \label{pcode:rdg3}
\end{algorithm}

% TODO opiši algoritem RDG3
% TODO dodaj primerjavo med RDG2--RDG3

\begin{algorithm}
    \DontPrintSemicolon
    \KwIn{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\alpha$, $k$}
    \SetKwFunction{Inter}{Interact2}
    \SetKwFunction{app}{Pripni}

    $\mathbf{a}$, $\mathbf{G}$ \gets~ [], []\;
    $\mathbf{x}_{l,l}$, $y_{l,l}$ \gets~ $\mathbf{b}_{\downdownarrows}$, $f(\mathbf{b}_{\downdownarrows})$\;
    $\mathbf{s}_1$, $\mathbf{s}_2$ \gets~ [1], [\lFor*{$i=2$ \KwTo \ell($\mathbf{b}_{\downdownarrows}$)}{$i$}]\;
    \While{\ell($\mathbf{s}_2$) > 0}{
        $\mathbf{x}_{u,l}$ \gets~ $\mathbf{x}_{l,l}$\;
        $\mathbf{x}_{u,l}$[$\mathbf{s}_1$] \gets~ $\mathbf{b}_{\upuparrows}$[$\mathbf{s}_1$]\;
        $y_{u,l}$ \gets~ $f(\mathbf{x}_{u,l})$\;
        $\mathbf{s}^*$ \gets~ \Inter{$f$, $\mathbf{x}_{l, l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{x}_2$, [$y_{l,l}$, -$y_{u,l}$, $\infty$, $\infty$]}\tcp*[f]{Algoritem~\ref{pcode:erdg:interact}}\;
        \eIf{\ell($\mathbf{s}^*$) = \ell($\mathbf{s}_1$)}{
            \eIf{\ell($\mathbf{s}_1$) = $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1[:1]$\;
            }{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
            }
            $\mathbf{s}_1$ \gets~ $\mathbf{s}_2[:1]$\;
            $\mathbf{s}_2$ \gets~ $\mathbf{s}_2[1:]$\;
        }{
            $\mathbf{s}_1$ \gets~ $\mathbf{s}^*$\;
            $\mathbf{s}_2$ \gets~ [\lForEach*{$e$ in $\mathbf{s}_2$}{\lIf*{$e$ not in $\mathbf{s}_1$}{$e$}}]\;
        }
        \If{\ell($\mathbf{s}_2$) = $0$}{
            \uIf{\ell($\mathbf{s}_1$) > 1}{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
            }
            \ElseIf{\ell($\mathbf{s}_1$) = $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$\;
            }
        }
    }
    \ForEach{$e$ in $\mathbf{a}$}{
        \app{$\mathbf{G}$, $e$}\;
    }
    \Return $\mathbf{G}$\;

    \caption{Algoritem ERDG~\cite{alg:erdg} za dekompozicijo problema.}
    \label{pcode:erdg}
\end{algorithm}

\begin{algorithm}
    \DontPrintSemicolon
	\KwIn{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\mathbf{y}$}
	\SetKwFunction{Inter}{Interact2}
    \SetKwFunction{floor}{floor}

    $s$, $\mathbf{s}$ \gets~ \textbf{True}, $\mathbf{s}_1$\;
    \If{$\infty$ in $\mathbf{y}$}{
        $\mathbf{x}_{l,m}$, $\mathbf{x}_{u,m}$ \gets~ $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$\;
        $\mathbf{x}_{l,m}$, $\mathbf{x}_{u,m}$ \gets~ $\frac{\mathbf{b}_{\downdownarrows} + \mathbf{b}_{\upuparrows}}{2}$[$\mathbf{s}_2$], $\frac{\mathbf{b}_{\downdownarrows} + \mathbf{b}_{\upuparrows}}{2}$[$\mathbf{s}_2$]\;
        $\mathbf{y}$[$3$], $\mathbf{y}$[$4$] \gets~ -$f(\mathbf{x}_{l,m})$, $f(\mathbf{x}_{u,m})$\;
        \If{$|\sum{\mathbf{y}}|$ $\leqslant$ $\epsilon$}{
            $s$ \gets~ \textbf{False}\;
        }
    }
    \If{$s$}{
        \eIf{\ell($\mathbf{s}_2$) = $1$}{
            $\mathbf{s}$ \gets~ $\mathbf{s}_1 \cup \mathbf{s}_2$\;
        }{
            $k$ \gets~ \floor{\ell($\mathbf{s}_2$) / $2$}\;
            $\mathbf{g}_1$, $\mathbf{g}_2$ \gets~ $\mathbf{s}_2$[:$k$], $\mathbf{s}_2$[$k$:]\;
            $\mathbf{x}_1$, $\mathbf{y}_n$ \gets~ \Inter{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_1$, [$\mathbf{y}$[1], $\mathbf{y}$[2], $\infty$, $\infty$]}\tcp*[f]{Algoritem~\ref{pcode:erdg:interact}}\;
            \eIf{$\sum{\mathbf{y}} - \sum{\mathbf{y}_n}$ $\neq$ $0$}{
                \eIf{\ell($\mathbf{x}_1$) = \ell($\mathbf{s}_1$)}{
                    $\mathbf{x}_2$, \_ \gets~ \Inter{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_2$, $\mathbf{y}$}\tcp*[f]{Algoritem~\ref{pcode:erdg:interact}}\;
                }{
                    $\mathbf{x}_2$, \_ \gets~ \Inter{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_2$, [$\mathbf{y}$[1], $\mathbf{y}$[2], $\infty$, $\infty$]}\tcp*[f]{Algoritem~\ref{pcode:erdg:interact}}\;
                }
                $\mathbf{s}$ \gets~ $\mathbf{x}_1 \cup \mathbf{x}_2$\;
            }{
                $\mathbf{s}$ \gets~ $\mathbf{x}_1$\;
            }
        }
    }
    \Return{$\mathbf{s}$, $\mathbf{y}$}\;
     
	\caption{Funkcija \texttt{Interact2} za detekcijo interakcije med komponentami pri algoritmu ERDG.}
	\label{pcode:erdg:interact}
\end{algorithm}

% TODO opiši algoritem ERDG
% TODO dodaj primerjavo med RDG3--ERDG

\begin{algorithm}
    \DontPrintSemicolon
    \KwIn{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\alpha$, $k$}
    \SetKwFunction{group}{Group}
    \SetKwFunction{app}{Pripni}

    $\epsilon$ \gets~ $\alpha \cdot \min(|f(\mathbf{x}_1)|, \cdots, |f(\mathbf{x}_{\frac{k}{4}})|)$\;
    $\mathbf{a}$, $\mathbf{G}$ \gets~ [], []\;
    $\mathbf{x}_{l,l}$, $y_{l,l}$ \gets~ $\mathbf{b}_{\downdownarrows}$, $f(\mathbf{b}_{\downdownarrows})$\;
    $\mathbf{s}_1$, $\mathbf{s}_2$ \gets~ [1], [\lFor*{$i=2$ \KwTo \ell($\mathbf{b}_{\downdownarrows}$)}{$i$}]\;
    \While{\ell($\mathbf{s}_2$) > 0}{
        $\mathbf{x}_{u,l}$ \gets~ $\mathbf{x}_{l,l}$\;
        $\mathbf{x}_{u,l}$[$\mathbf{s}_1$] \gets~ $\mathbf{b}_{\upuparrows}$[$\mathbf{s}_1$]\;
        $y_{u,l}$ \gets~ $f(\mathbf{x}_{u,l})$\;
        $\mathbf{s}^*$ \gets~ \group{$f$, $\mathbf{x}_{l, l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\epsilon$, $y_{l,l} - y_{u,l}$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
        \eIf{\ell($\mathbf{s}^*$) = \ell($\mathbf{s}_1$)}{
            \eIf{\ell($\mathbf{s}_1$) = $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1[:1]$\;
            }{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
            }
            $\mathbf{s}_1$ \gets~ $\mathbf{s}_2[:1]$\;
            $\mathbf{s}_2$ \gets~ $\mathbf{s}_2[1:]$\;
        }{
            $\mathbf{s}_1$ \gets~ $\mathbf{s}^*$\;
            $\mathbf{s}_2$ \gets~ [\lForEach*{$e$ in $\mathbf{s}_2$}{\lIf*{$e$ not in $\mathbf{s}_1$}{$e$}}]\;
        }
        \If{\ell($\mathbf{s}_2$) = $0$}{
            \uIf{\ell($\mathbf{s}_1$) > 1}{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
            }
            \ElseIf{\ell($\mathbf{s}_1$) = $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$\;
            }
        }
    }
    \ForEach{$e$ in $\mathbf{a}$}{
        \app{$\mathbf{G}$, $e$}\;
    }
    \Return $\mathbf{G}$\;

    \caption{Algoritem TRDG~\cite{alg:trdg} za dekompozicijo problema.}
    \label{pcode:trdg}
\end{algorithm}

\begin{algorithm}
    \DontPrintSemicolon
	\KwIn{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_2$, $\epsilon$, $\delta$}

    $\mathbf{x}_{l,m}$, $\mathbf{x}_{u,m}$ \gets~ $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$\;
    $\mathbf{x}_{l,m}$, $\mathbf{x}_{u,m}$ \gets~ $\frac{\mathbf{b}_{\downdownarrows} + \mathbf{b}_{\upuparrows}}{2}$[$\mathbf{s}_2$], $\frac{\mathbf{b}_{\downdownarrows} + \mathbf{b}_{\upuparrows}}{2}$[$\mathbf{s}_2$]\;
    $y_{l,m}$, $y_{u,m}$ \gets~ $f(\mathbf{x}_{l,m})$, $f(\mathbf{x}_{u,m})$\;
    \eIf{$|\delta - (y_{l,m} - y_{u,m})|$ > $\epsilon$}{
        \Return{\textbf{True}}\;
    }{
        \Return{\textbf{False}}\;
    }

	\caption{Funkcija \texttt{Interact3} za detekcijo interakcije med komponentami.}
	\label{pcode:trdg:interact}
\end{algorithm}

\begin{algorithm}
    \DontPrintSemicolon
	\KwIn{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\epsilon$, $\delta$}
    \SetKwFunction{group}{Group}
    \SetKwFunction{Inter}{Interact3}
    \SetKwFunction{floor}{floor}
    \SetKwFunction{app}{Pripni}


    $\mathbf{s}^*$ \gets~ $\mathbf{s}_1$\;
    \If(\tcc*[f]{Algoritem~\ref{pcode:trdg:interact}}){\Inter{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_2$, $\epsilon$, $\delta$}}{
        \uIf{\ell($\mathbf{s}_2$) = $1$}{
            $\mathbf{s}^*$ \gets~ $\mathbf{s}_1 \cup \mathbf{s}_2$\;
        }
        \uElseIf{\ell($\mathbf{s}_2$) = $2$}{
            $\mathbf{g}_1$, $\mathbf{g}_2$ \gets~ $\mathbf{s}_2$[:$1$], $\mathbf{s}_2$[$1$:]\;
            $\mathbf{x}_1$ \gets~ \group{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_1$, $\epsilon$, $\delta$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
            $\mathbf{x}_2$ \gets~ \group{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_2$, $\epsilon$, $\delta$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
            $\mathbf{s}^*$ \gets~ $\mathbf{x}_1 \cup \mathbf{x}_2$\;
        }
        \Else{
            $k$ \gets~ \floor{\ell($\mathbf{s}_2$) / $3$}\;
            $\mathbf{g}_1$, $\mathbf{g}_2$, $\mathbf{g}_3$ \gets~ $\mathbf{s}_2$[:$k$], $\mathbf{s}_2$[$k$:$2 \cdot k$], $\mathbf{s}_2$[:$2 \cdot k$]\;
            $\mathbf{x}_1$ \gets~ \group{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_1$, $\epsilon$, $\delta$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
            $\mathbf{x}_2$ \gets~ \group{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_2$, $\epsilon$, $\delta$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
            $\mathbf{x}_3$ \gets~ \group{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_3$, $\epsilon$, $\delta$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
            $\mathbf{s}^*$ \gets~ $\mathbf{x}_1 \cup \mathbf{x}_2 \cup \mathbf{x}_3$\;
        }
    }
    \Return{$\mathbf{s}^*$}\;

	\caption{Funkcija \texttt{Group} za grupiranje komponent pri algoritmu TRDG.}
	\label{pcode:trdg:group}
\end{algorithm}

% TODO opiši algoritem TRDG
% TODO dodaj primerjavo med ERDG--TRDG

\section{Omejitve sorodnih del}

% TODO

\chapter{Koevolucijski algoritem rojev delcev}\label{chap:algo}

% TODO

\begin{algorithm}
    \DontPrintSemicolon
	\KwIn{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$}
	\SetKwFunction{run}{Generacija}
	\SetKwFunction{Decom}{Dekompozicija}
	\SetKwFunction{appbetter}{Posodobi}

	$\mathbf{g}$ \gets~ \Decom{$f$, $\mathbf{b}_{\downdownarrows}$, $\mathbf{b}_{\upuparrows}$}\;
	$\mathbf{a}$ \gets~ [\lForEach*{$g$ in $\mathbf{g}$}{Inicializirja začetno populacijo algoritma $a$ na podlagi grupe $g$}]\;
    $\mathbf{X^*}$, $\mathbf{y}^*$ \gets~ Pridobi najboljše posameznike vsake grupe\;
	%$\mathbf{x^*}$, $y^*$ \gets~ Get best individual and fitness value from $\mathbf{X^*}$\;
	$\mathbf{x^*}$, $y^*$ \gets~ Najdi najboljšega posameznika iz $\mathbf{X^*}$\;
	\While{$\neg$ zaustavitveni pogoj zadovoljen}{
		\ForEach{$i$, $a$ in $\mathbf{a}$}{
			$\mathbf{x_n^*}$, $y_n^*$ \gets~ \run{$a$}\;
			\If{$y_n^* < \mathbf{y^*}[i]$}{
				$\mathbf{X^*}[i]$, $\mathbf{y^*}[i]$ \gets~ $\mathbf{x_n^*}$, $y_n^*$\;
				\If{$y_n^* < y^*$}{
                    $\mathbf{x^*}$, $y^*$ \gets~ $\mathbf{x_n^*}$, $y_n^*$
                }
			}
		}
        \If{Katera od grup našla novo lokalno najboljšo rešitev}{
		    \ForEach{$g$ in $\mathbf{g}$}{
                $\mathbf{x_n}[g]$ \gets~ $\mathbf{X^*}[g]$
            }
		    $y_n$ \gets~ $f(\mathbf{x_n})$\;
		    \If{$y_n < y^*$}{
                $\mathbf{x^*}$, $y^*$ = $\mathbf{x_n}$, $y_n$
            }
        }
	}
	\Return{$\mathbf{x^*}$, $y^*$}\;

	\caption{Predlagan koevolucijski algoritem.}
	\label{pcode:ccalgo}
\end{algorithm}

\chapter{Eksperiment}\label{chap:exp}

% TODO

\section{Primerjava uporabe metod RDG}

% TODO

\begin{table}[t]
    \centering
    \caption{Vrednosti parametrov metod za grupiranje.} \label{tab:algs:group_params}
    \begin{tabular}{|c|c|}
        \hline
        Algoritem & Vrednosti parametrov \\\hline
        RDG & $\alpha = 10\mathrm{e}{-12}$, $k = 10$ \\\hline
        RDG2 & $\alpha = 10\mathrm{e}{-12}$ \\\hline
        RDG3 & $\alpha = 10\mathrm{e}{-12}$, $\epsilon_n = 50$, $\epsilon_s = 100$ \\\hline
        ERDG & $\alpha = 10\mathrm{e}{-12}$ \\\hline
        TRDG & $\alpha = 10\mathrm{e}{-12}$, $k = 10$ \\\hline
    \end{tabular}
\end{table}

% TODO dodaj podatek zakaj si uporabil take vrednosti parametrov
% Večina vrednosti parametrov sem pridobil iz literature o teh algorithmih, saj so pri vsaki raziskavi izvedli tudi analizo parametrov za naš izbrani problem CEC2013

\subsection{Analiza rezultatov}

% TODO

\section{Primerjava PSO algoritmov z metodami RDG}

% TODO

\subsection{Analiza rezultatov}

% TODO

\chapter{Zaključek}\label{chap:end}

% TODO
