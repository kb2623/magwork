\chapter{Uvod}\label{cahp:uvod}
S problemi velikih dimenzij se med drugim srečujemo na različnih področjih, kot so telekomunikacije~\cite{bib:lsgo:telecommunication}, logistika~\cite{bib:lsog:logistics}, strojništvo~\cite{bib:lsgo:engineering} itd.
Ti problemi zahtevajo iskanje optimalnih rešitev v obsežnem iskalnem prostoru, kjer ima problem veliko število odločitvenih spremenljivk.
Pri takih problemih tradicionalni optimizacijski algoritmi, kot so to metode, ki temeljijo na gradientu, kvadratno programiranje in linearno programiranje, se soočajo s težavami.
Inteligenca rojev (ang. \textit{Swarm inteligence} (SI)) se je pojavila, kot obetaven pristop za reševanje problemov velikih dimenzij zaradi svoje zmožnosti učinkovitega raziskovanja prostora, obvladovanja šumnih in ne-konveksnih cenitvenih funkcij, ter obvladovanja velikega števila parametrov objektivne funkcije.

Inteligenca rojev se nanaša na kolektivno vedenje decentraliziranih, samoorganiziranjih sistemov, sestavljenih iz več agentov, ki sodelujejo med seboj in v okolju, da bi dosegli skupni cilj.
Agenti v sistemih SI so lahko umetni ali naravni, komunicirajo in usklajujejo pa se po preprostih lokalnih pravilih.
Vedenje teh agentov se zgleduje po vedenju družbenih žuželk, kot so mravlje, čebele in termiti, ki v svojih kolonijah kažejo izjemne sposobnosti reševanja problemov.

Eden najbolj priljubljenih SI algoritmov za reševanje problemov velikih dimenzij je algoritem roja delcev (ang. \textit{Particle Swarm Optimization} (PSO))~\cite{alg:pso}.
PSO algoritem sta prvič predlagala Ebarhart in Kennedy leta 1995 in je od takrat pridobil široko pozornost zaradi svoje preprostosti, robustnosti in učinkovitosti.
PSO algoritem deluje tako, da simulira vedenje skupine delcev, ki se premikajo v iskalnem prostoru, da bi našli optimalno rešitev.
Vsak delec predstavlja kandidatno rešitev problema, njegovo gibanje pa je odvisno od njegove lastne hitrosti in najboljše rešitve, ki jo je skupina delcev doslej našla.

Druga algoritma rojev delcev, ki je sta lahko uporabljen za optimizacijo velikih dimenzij sta algoritem optimizacije kolonije mravelj (ang. \textit{Ant Colony Optimization} (ACO))~\cite{alg:aco} pri iskanju hrane in algoritem umetne čebelje kolonije (ang. \textit{Artificial Bee Colony} (ABC))~\cite{alg:abc}, ki posnema vedenje iskanja hrane čebel.
ACO algoritem deluje tako, da zgradi graf rešitve, ki predstavlja prostor iskanja, mravlje se premikajo po tem grafu, kjer preiskujejo prostor in iščejo nove boljše rešitve problema.
ABC algoritem zaposluje skupino čebel, ki iščejo iskalni prostor za vire hrane, pri čemer vsaka čebela predstavlja kandidatno rešitev problema.

Glavna prednost uporabe SI algoritmov za optimizacijo problemov velikih dimenzij je njihova sposobnost obvladovanja kompleksnosti in velike dimenzionalnosti iskalnega prostora.
Tradicionalni optimizacijski algoritmi se soočajo s težavami pri reševanju takih problemov zaradi visokih računskih stroškov in prisotnosti večih lokalnih optimumov.
Nasprotno pa SI algoritmi uporabljajo preprosta lokalna pravila za učinkovito raziskovanje iskalnega prostora in so odpornejši na lokalne optimume, v katerih lahko obtičijo mnogi tradicionalni algoritmi.

Uporabo SI algoritmov za optimizacijo problemov velikih dimenzij, lahko opazimo na mnogih področjih, kot so strojništvo, finance in logistika.
V strojništvu so bili SI algoritmi uporabljeni za optimizacijo kompleksnih sistemov, kot so letala, turbine in motorji.
V finančnem sektorju so bili SI algoritmi uporabljeni za optimizacijo portfelja in obvladovanje tvegan podjetji.
V logistiki so bili SI algoritmi uporabljeni za optimizacijo usmerjanja vozil, upravljanja s skladiščem in optimizacije dobavne verige.
SI algoritmi so se izkazali za zelo učinkovite in njihov uspeh je spodbudil nadaljnje raziskave razvoja novih in izboljšanih algoritmov.

Kljub prednostim SI algoritmov imajo tudi ti algoritmi nekatere omejitve, kot so počasna stopnja konvergence, potreba po velikem številu ovrednotenj cenitvene funkcije in občutljivosti na nastavitve parametrov algoritma.
Za premagovanje teh omejitev so raziskovali predlagali več modifikacij in hibridizacij SI algoritmov, kot je hibridizacija z lokalnimi iskalnimi metodami, operatorji mutacije in hibridizacija z drugimi optimizacijskimi algoritmi.

V zadnjih letih so raziskovalci uvedli koncept diferencialnega združevanja in koevolucije kot nove strategije za izboljšanje učinkovitosti optimizacijskih algoritmov za reševanje problemov velikih dimenzij.
Cilj teh strategij je izboljšati proces iskanja z razdelitvijo optimizacijskega problema na manjše podprobleme in sočasno uporabo optimizacijskih algoritmov za optimizacijo vsakega podproblema.
Podproblemi se nato uskladijo z diferencialnim združevanjem in koevoluciskimi mehanizmi, na način da vodijo celoten proces iskanja k boljšim rešitvam.

Koevolucija je tehnika, ki podpira reševanje hkraten razvoj večih populacij, ki rešujejo svoj podproblem.
Podproblemi medsebojno delujejo in vplivajo na razvoj drug drugega, ter ustvarjajo dinamično in konkurenčno okolje.
Koevolucija spodbuja raziskovanje različnih regij iskalnega prostora in spodbuja izmenjavo informacij med podproblemi.
Ta kooperativna interakcija med podproblemi lahko vodi do odkritja boljših rešitev in izboljšanja konvergentnih lastnosti.

Kombinacija diferencialnega združevanja in koevelucije za hribidizacijo optimizacijskih algoritmov je pokazala obetavne rezultate pri reševanju problemov velikih dimenzij.
Te strategije izkoriščajo prednosti obeh tehnik, kar omogoča učinkovito raziskovanje in izkoriščanje iskalnega prostora.
Z razčlenitvijo problema na manjše podprobleme in uporabo optimizacijskih algoritmov postane proces iskanja bolj osredotočen in učinkovit.

Motivacija za to diplomsko delo izhaja iz potrebe po obravnavanju naraščajočega povpraševanja po učinkovitih in uspešnih rešitvah problemov velikih dimenzij.
S pojavom vele podatkov (ang. \textit{Big Data}) in vse večjo kompleksnostjo sodobnih sistemov, tradicionalne optimizacijske tehnike ne zadoščajo za pravočasno zagotavljanje optimalnih rešitve.
PSO algoritmi ponujajo obetavno alternativo za reševanje teh zahtevnih problemov, vendar so potrebne nadaljnje raziskav, da bi v celoti razumeli njihove zmogljivosti in omejitve.

V tem diplomskem delu želimo raziskati učinkovitost kovelucijskega hibridnega PSO algoritma z rekurzivnimi diferencialnimi metodami grupiranja za reševanje problemov velikih dimenzij.
Raziskali bomo, kako lahko te strategije izboljšajo delovanje PSO algoritmov.
Z obsežnim eksperimentiranjem in primerjalno analizo bomo ovrednotili delovanje predlaganega algoritma v primerjavi z obstoječimi hibridnimi PSO algoritmi.
S preučevanjem njegove hitrosti konvergence, kakovosti rešitev in robustnosti želimo zagotoviti vpogled v potencialne prednosti in omejitve novega hibridnega algoritma v kontekstu problemov velikih dimenzij.
Z vključitvijo konceptov diferencialnega grupiranja in koevolucije v hibridne PSO algoritme pričakujemo, da bomo premagali nekatere omejitve in izzive, ki jih predstavljajo optimizacijski problemi velikih dimenzij.
Te strategije imajo potencial za izboljšanje zmožnosti raziskovanja in izkoriščanja optimizacijskih algoritmov,  kar vodi do učinkovitejših in uspešnejših rešitev.
Preiskava teh tehnik v kontekstu problemov veliki dimenzij je ključnega pomena za napredek na področju optimizacijskih algoritmov iz zagotavljanja praktičnih rešitev za aplikacije v resničnem svetu.

Prispevki tega diplomskega dela naj bi vključevali:
\begin{enumerate}
    \item Obsežen pregled literature o PSO algoritmih, vključno zz analizo prednosti in omejitev različnih PSO algoritmov.
    \item Vrednotenje delovanja različnih PSO algoritmov na problemih velikih dimenzij, ki vključujejo multimodalne funkcije, popolnoma odvedljive funkcije, delno aditivno odvedljive funkcije, funkcije s prekrivajočimi komponentami in ne-odvedljive funkcije.
    \item Raziskovanje vpliva različnih uporabljenih metod hibridizacije PSO algoritma na problemih velikih dimenzij.
    \item Priporočila za izbiro in nastavitve hibridiziranih PSO algoritmov za probleme velikih dimenzij, ki temeljijo na rezultatih naših poskusov.
\end{enumerate}

Preostanek tega diplomskega dela je organiziran na naslednji način.
V \ref{chap:obsojeca.dela}. poglavju ponujamo pregled literature o optimizacijskih algoritmih inteligence rojev za optimizacijo problemov velikih dimenzij.
To poglavje vključuje podrobno razpravo o prednostih in omejitvah različnih optimizacijskih algoritmov inteligence rojev, algoritmov grupiranja komponent, ki bazirajo na razlikah vpliva komponent, ter koevolucijskih algoritmih za reševanje problemov velikih dimenzij.
V \ref{chap:algo}. poglavju opisujemo novo hibidizacijo PSO algoritma, ki uporablja koevolucijo in grupiranje komponent za probleme velikih dimenzij.
To poglavje vključuje razpravo o uporabljenih metodah za modifikacijo hibridnega PSO algoritma, ter omejitvah novega hibridnega algoritma.
Poglavje vsebuje tudi priporočila za izbiro, nastavitev parametrov in omejitve hibridnih PSO algoritmov za probleme velikih dimenzij.
V \ref{chap:exp}. poglavju posredujemo rezultate naših poskusov in razpravljamo o uspešnosti različnih hibridnih PSO algoritmih na problemih velikih dimenzij.
To poglavje vključuje podrobno analizo vpliva različnih parametrov hibridnih PSO algoritmov.
Na koncu \ref{chap:end}. poglavju podajamo povzetek naših ugotovitev, zaključkom in predlogi za prihodnje raziskave na tem področju. Verjamemo, da bo ta diplomska naloga zagotovila dragocen vpogled v uporabo SI algoritmov za optimizacijo problemov velikih dimenzij in prispevala k razvoju učinkovitejših in uspešnejših optimizacijskih tehnik.

\chapter{Pregled obstoječih del}\label{chap:obsojeca.dela}

Prekletstvo dimenzionalnosti je od najzgodnejših časov prekletstva, ki je pestilo znanstvenike od najzgodnejših dni~\cite{bib:curse_of_dim}, krotenje pa je bilo v središču številnih raziskovalnih prizadevanj v računalniških znanostih, od računalniške linearne algebre~\cite{bib:COD:linear_algebra}, strojnega učenja~\cite{bib:COD:machine_learning} do numerične optimizacije~\cite{bib:COD:numerical_methods}.
Motiv na vseh teh področjih je oblikovati nove načine za izgradnjo razširljivih računalniških sistemov, ki so sposobni narediti več z manj.
V kontekstu numerične optimizacije je prekletstvo dimenzionalnosti posledica eksponentne rasti velikosti iskalnega prostora glede na povečanje števila vhodnih spremenljivk.
V zadnjih letih se to ohlapno imenuje globalna optimizacija velikega obsega ali globalna optimizacija problemov z velikim številom dimenzij (ang. \textit{Large Scale Global Optimization} (LSGO)).
Izraz globalna poudarja vlogo hevristike in metahevristike, zlasti v kontekstu nenehne optimizacije.
Treba je opozoriti, da se pojem velikega obsega spreminja skozi čas in se razlikuje od problema do problema.
V tem delu se za velik problem šteje problem, ki povzroča težave z razširljivostjo na najsodobnejših algoritmih.
Natančneje, posamezen problem ciljne optimizacije je mogoče definirati na naslednji način (ob predpostavki minimizacije):
\begin{align}
	&\min_{\mathbf{x}^*}{f(\mathbf{x})} \label{eq:min_opt}\\
	&\mathbf{x} = (x_1, \cdots, x_D) \in \Omega \label{eq:min_opt_space},
\end{align}
kjer $\Omega$ predstavlja celotni iskalni prostor, ter $\mathbf{x}$ predstavlja točko znotraj $\Omega$ iskalnega prostora, kar je razvidno iz enačbe (\ref{eq:min_opt_space}).
Funkcija $f$ predstavlja ocenitveno funkcijo, ki jo minimiziramo, kar predstavlja enačba~(\ref{eq:min_opt}).
Optimizacija velikega obsega se ukvarja z razširljivostjo optimizacijskih algoritmov, ko $D$ raste v velikosti oziroma presega vrednost $100$.
Problem ima lahko dodatne omejitve, ki nam še dodatno otežijo reševanje podanega problema.
V tem delu se bomo osredotočili na probleme, ki so omejeni le z zgornjo in spodnjo mejo iskalnega prostora.

Hiter tehnološki napredek povzroča nastanek vedno večjih problemov optimizacije na različnih področjih.
Za na primer v gradbeništvu vstopamo v tako imenovano dobo megavisokih stavb s konstrukcijo gradnja prvega kilometra visoke stavbe že poteka~\cite{bib:tallest_20}.
To je povzročilo optimizacijske probleme v gradbenem inženirstvu~\cite{bib:lsgo_engineering}.
Fenomen eksplozije podatkov je povzročil nastanek zahtevne obsežne optimizacije v središču mnogih podatkovnih analiz in strojnega učenja~\cite{bib:lsgo_machine_learning}.
Napredek v strojnem učenju in vzpon globokih umetnih nevronskih mrež je povzročil tudi optimizacijske težave z več kot milijardo spremenljivkami~\cite{bib:lsgo_deep_learning}.
Te težave z optimizacijo ne rastejo samo z velikostjo linearno, ampak tudi rastejo na eksponenten način, tj. število odločitvenih spremenljivk povzročajo tudi eksponentno rast~\cite{bib:lsgo_exponential_grouth}.
Ta hitra rast je spodbudil znanstvene raziskave na različnih področjih za izgradnjo sposobni optimizacijski algoritmi.
Dominanca računalništva in matematike je pokazatelj pomena algoritemskih vidikov oblikovanja učinkovite metode optimizacije.

Razširljivost optimizacijskih algoritmov je velik izziv pri spopadanju z vedno večjim obsegom optimizacijskih problemov na številnih področjih uporabe od visokodimenzionalnega strojnega učenja do kompleksnih obsežnih inženirskih problemov.
Področje obsežne globalne optimizacije se ukvarja z izboljšanjem razširljivosti globalnih optimizacijskih algoritmov, zlasti metahevristik, ki temeljijo na populaciji.
Takšne metahevristike so bile uspešno uporabljene za zvezne, diskretne ali kombinatorne probleme, ki segajo od več tisoč do milijarde odločitvenih spremenljivk.
V tem delu pregledujemo nedavne študije na področju globalne optimizacije problemov velikih dimenzij obravnavanih kot črne škatle, da bi raziskovalcem in izvajalcem pomagali pridobiti pogled na to področje iz ptičje perspektive, se seznaniti z njegovimi glavnimi trendi in stanjem najsodobnejših algoritmih.
Štirje glavni algoritemski pristopi za reševanje problemov LSGO so:
\begin{enumerate}
	\item razčlenitev problema,
	\item populacijski algoritmi,
	\item memetične algoritme in
	\item metode lokalnega iskanja.
\end{enumerate}
V nadaljevanju sledijo opisi algoritemskih pristopov k obsežno globalno optimizacijo, opisuje širok spekter problemskih področij in se končno dotakne pasti in izzivov trenutnih raziskav ter identificira več potencialnih področij za prihodnje raziskave.

\section{Roj delcev}

Inteligenca rojev (ang. \textit{Swarm Intelligence} (SI)) je bila predstavljena v knjigi~\cite{bib:swarm_intelligence}, kjer je bila uporabljana za reševanje različnih tipov problemov.
Ko govorimo o SI, mora biti izpolnjenih načela paradigme SI.
Omenjena načela je opredelil Milonas~\cite{bib:si_principles} že leta 1994 in obsegajo načelo bližine, načelo kakovosti, načelo raznolikega odziva, načelo stabilnosti in načelo prilagodljivosti.
Stalna rast znanstvenih člankov na temo SI kaže, da je SI ena najbolj obetavnih oblik računske inteligence (ang. \textit{Computational Intelligence} (CI))~\cite{bib:computational_intelligence}.
K temu nedvomno prispevajo prednosti SI.
Ena najbolj očitnih prednosti je avtonomija.
Roj nima zunanjega upravljanja, vendar ima agente.
Agenti v roju avtonomno nadzoruje svoje vedenje.
Agent v tem primeru predstavlja možno rešitev danega problema.
Druga prednost je samoorganizacija.
Inteligenca se izpostavlja v obnašanju vseh agentov oziroma roja, ampak ne samo v vedenju enega agenta.
Rešitve problema niso vnaprej znane, ampak se spreminjajo v času razvoja roja oziroma izvajanja programa.
Samoorganizacija igra pomembno vlogo pri prilagodljivosti.
Opazna je v spreminjajočih se okoljih.
Agenti se dobro odzovejo na spremembe, prilagodijo svoje vedenje.
To agentom omogoča avtonomno prilagajajo.
Roj ni odvisen od centralne koordinacije, zato je roj robusten, ter ni ene same točke odpovedi.
Roj omogoča tudi redundanco, kar omogoča še dve dodatni prednosti.
Prva je razširljivost.
Roj je lahko sestavljen iz nekaj do največ tisoč agentov, ter še vedno lahko ostaja arhitektura nadzora enaka.
Druga je pogrešljivost.
Ker ni samo enega samega agenta, bistvenega za roj, je prilagodljivost prednosti SI v celoti izpolnjena.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{img/si_algo_dp.pdf}
    \caption{Diagram poteka za osnovi algoritem SI~\cite{bib:swarm_intelligence}.}\label{fig:si_algo_dp}
\end{figure}

Vsak algoritem SI upošteva nekatere temeljne faze.
Slika~\ref{fig:si_algo_dp} prikazuje možno definicijo algoritmov SI, 
Opazimo lahko naslednje pomembne korake algoritmov SI:
\begin{enumerate}
    \item inicializacija agentov,
    \item ocenitev agentov,
    \item posodobitev agentov,
    \item preverjanje zaustavitvenega pogoja in
    \item vračanje najboljšega posameznika.
\end{enumerate}
V tem delu bomo bomo uporabili sedem različnih algoritmov, ki pripadajo skupini algoritmov SI.
Konkretno bomo uporabili sedem različnih algoritmov roja delcev.
Uporabljeni bodo algoritmi:
\begin{enumerate}
    \item algoritem roja delcev (ang. \textit{Particle Swarm Optimization} (PSO))~\cite{alg:pso},
    \item algoritem roja delcev s centralnim iskanjem (ang. \textit{Center Particle Swarm Optimization} (CPSO))~\cite{alg:cpso},
    \item algoritem roja delcev z dodano mutacijo delcev (ang. \textit{Mutated Particle Swarm Optimization} (MPSO))~\cite{alg:mpso},
    \item algoritem roja delcev z dodano mutacijo delcev in centralnim iskanjem (ang. \textit{Mutated Center Particle Swarm Optimization} (MCPSO)),
    \item algoritem roja delcev s celovitim učenjem (ang. \textit{Comprehensive Learning Particle Swarm Optimizer} (CLPSO))~\cite{alg:clpso},
    \item ?? (ang. \textit{Mutated Center Unified Particle Swarm Optimization} (MCUPSO))~\cite{alg:mcupso} in
    \item algoritem roja delcev z uporabo nasprotji in omejevanjem hitrosti (ang. \textit{Opposition-Based Particle Swarm Optimization with Velocity Clamping} (OVCPSO))~\cite{alg:ovcpso}.
\end{enumerate}
V nadaljevanju sledijo podrobnejši opisi vsakega od uporabljenih algoritmov 

\section{Diferencialne metode grupiranja}

% TODO Opiši kaj je to metoda grupiranja

Uporabljeni bodo naslednji algoritmi:
\begin{enumerate}
    \item rekurzivno diferencialno grupiranje (ang. \textit{RecursiveDifferentialGrouping} (RDG))~\cite{alg:rdg},
    \item rekurzivno diferencialno grupiranje verzije 2 (ang. \textit{Recursive Differential Grouping V2} (RDGV2))~\cite{alg:rdg2},
    \item rekurzivno diferencialno grupiranje verzije 3 (ang. \textit{Recursive Differential Grouping V3} (RDGV3))~\cite{alg:rdg3},
    \item efektivno rekurzivno diferencialno grupiranje (ang. \textit{Efficient Recursive Differential Grouping} (ERDG))~\cite{alg:erdg} in
    \item tri nivojsko rekurzivno diferencialno grupiranje (ang. \textit{Three Level Recursive Differential Grouping} (TRDG))~\cite{alg:trdg}.
\end{enumerate}

\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{rdg}{RDG}
    \SetKwFunction{Inter}{Interact}
    \SetKwFunction{app}{Pripni}

    \Fn{\rdg{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\alpha$, $k$}}{
    $\mathbf{x}_r$, $\mathbf{a}$, $\mathbf{G}$ \gets~ [1], [], []\;
    $\epsilon$ \gets~ $\alpha \cdot \min \left(|f(\mathbf{x}_1)|, \cdots, \left|f(\mathbf{x}_k) \right| \right)$\;
    $\mathbf{x}_{l,l}$, $y_{l,l}$ \gets~ $\mathbf{b}_{l}$, $f(\mathbf{b}_{u})$\;
    $\mathbf{s}_1$, $\mathbf{s}_2$ \gets~ [1], [\lFor*{$i=2$ \KwTo \ell($\mathbf{b}_{l}$)}{$i$}]\;

    \While{\ell($\mathbf{x}_r$) > 0}{
        $\mathbf{x}_r$ \gets~ []\;
        $\mathbf{s}^*$ \gets~ \Inter{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $y_{l,l}$, $\epsilon$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\mathbf{x}_r$}\tcp*[f]{Algoritem~\ref{pcode:rdg:interact}}\;
        \eIf{\ell($\mathbf{s}^*$) $=$ \ell($\mathbf{s}_1$)}{
            \leIf{\ell($\mathbf{s}_1$) $=$ $1$}{$\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$}{\app{$\mathbf{G}$, $\mathbf{s}_1$}}
            \eIf{\ell(\app{$\mathbf{x}_r$} > $1$)}{
                $\mathbf{s}_1$ \gets~ $\mathbf{x}_r$[:1]\;
                $\mathbf{x}_r$ \gets~ $\mathbf{x}_r$[1:]\;
                $\mathbf{s}_2$ = $\mathbf{x}_r$\;
            }{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$\;
                \textbf{break}\;
            }
        }{
            $\mathbf{s}_1$ \gets~ $\mathbf{s}^*$\;
            $\mathbf{s}_2$ \gets~ $\mathbf{x}_r$\;
            \If{\ell($\mathbf{s}_r$) = $0$}{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
                \textbf{break}\;
            }
        }
    }
    \lForEach{$e$ in $\mathbf{a}$}{\app{$\mathbf{G}$, $[e]$}}
    \Return $\mathbf{G}$\;
    }

    \caption{Algoritem RDG~\cite{alg:rdg} za dekompozicijo problema.}
    \label{pcode:rdg}
\end{algorithm}

\begin{algorithm}
    \DontPrintSemicolon
	\SetKwFunction{Inter}{Interact}
    \SetKwFunction{floor}{floor}

	\Fn{\Inter{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $y_{l,l}$, $\epsilon$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\mathbf{x}_r$}}{
    $\mathbf{x}_{u,l}$, $\mathbf{x}_{l,m}$ \gets~ $\mathbf{x}_{l,l}$, $\mathbf{x}_{l,l}$\;
    $\mathbf{x}_{u,m}$, $\mathbf{x}_{u,l}$ \gets~ $\mathbf{b}_{u}$[$\mathbf{s}_1$], $\mathbf{b}_{u}$[$\mathbf{s}_2$]\;
    $\mathbf{x}_n$ \gets~ $\mathbf{s}_1$\;
    $\mathbf{x}_{l,m}$, $\mathbf{x}_{u,m}$ \gets~ $\frac{\mathbf{b}_{l} + \mathbf{b}_{u}}{2}$[$\mathbf{s}_2$], $\frac{\mathbf{b}_{l} + \mathbf{b}_{u}}{2}$[$\mathbf{s}_2$]\;
    $y_{u,l}$, $y_{l,m}$, $y_{u,m}$ \gets~ $f(\mathbf{x}_{u,l})$, $f(\mathbf{x}_{l,m})$, $f(\mathbf{x}_{u,m})$\;
    $\sigma_1$, $\sigma_2$ \gets~ $y_{l,l} - y_{u,l}$, $y_{l,m} - y_{u,m}$\;

    \eIf{$|\sigma_1 - \sigma_2| > \epsilon$}{ \label{pcode:inter:test}
        \eIf{\ell($\mathbf{s}_2$) $=$ $1$}{
            $\mathbf{x}_n$ \gets~ $\mathbf{s}_1 \cup \mathbf{s}_2$\;
        }{
            $k$ \gets~ \floor{\ell($\mathbf{s}_2$) / 2}\;
            $\mathbf{g}_1$, $\mathbf{g}_2$ \gets~ $\mathbf{s}_2$[:$k$], $\mathbf{s}_2$[$k$:]\;
            $\mathbf{x}_1$ \gets~ \Inter{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $y_{l,l}$, $\epsilon$, $\mathbf{s}_1$, $\mathbf{g}_1$, $\mathbf{x}_r$}\tcp*[f]{Algoritem~\ref{pcode:rdg:interact}}\;
            $\mathbf{x}_2$ \gets~ \Inter{$f$, $\mathbf{b}_{i}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $y_{l,l}$, $\epsilon$, $\mathbf{s}_1$, $\mathbf{g}_2$, $\mathbf{x}_r$}\tcp*[f]{Algoritem~\ref{pcode:rdg:interact}}\;
            $\mathbf{x}_n$ \gets~ $\mathbf{x}_1 \cup \mathbf{x}_2$\;
        }
    }{
        $\mathbf{x}_r$ \gets~ $\mathbf{x}_r \cup \mathbf{s}_2$\;
    }
    \Return $\mathbf{x}_n$\;
    }
 
	\caption{Funkcija \texttt{Interact} za detekcijo interakcije med komponentami pri algoritmu RDG.}
	\label{pcode:rdg:interact}
\end{algorithm}

% TODO opiši algoritem RDG

\begin{equation}\label{eq:rdg2:epsilon}
    \epsilon = \frac{(y_{l,l} + y_{u,l} + y_{l,m} + y_{u,m}) \cdot (\sqrt{D} + 2) \cdot \frac{\alpha}{2}}{1 - (y_{l,l} + y_{u,l} + y_{l,m} + y_{u,m}) \cdot (\sqrt{D} + 2) \cdot \frac{\alpha}{2}}
\end{equation}

% TODO opiši algoritem RDG2, tukja predvsem kaj se spremeni napram prejšnjem
% TODO dodaj primerjavo med RDG--RDG2

\begin{algorithm}
    \DontPrintSemicolon

    \SetKwFunction{rdg}{RDG3}
    \SetKwFunction{Inter}{Interact}
    \SetKwFunction{app}{Pripni}

    \Fn{\rdg{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\alpha$, $\epsilon_n$, $\epsilon_s$}}{
    $\mathbf{x}_r$, $\mathbf{a}$, $\mathbf{G}$ \gets~ [1], [], []\;
    $\mathbf{x}_{l,l}$, $y_{l,l}$ \gets~ $\mathbf{b}_{l}$, $f(\mathbf{b}_{l})$\;
    $\mathbf{s}_1$, $\mathbf{s}_2$ \gets~ [1], [\lFor*{$i=2$ \KwTo \ell($\mathbf{b}_{l}$)}{$i$}]\;

    \While{\ell($\mathbf{x}_r$) $>$ $0$}{
        $\mathbf{x}_r$ \gets~ []\;
        $\mathbf{s}^*$ \gets~ \Inter{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $y_{l,l}$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\mathbf{x}_r$}\tcp*[f]{Algoritem~\ref{pcode:rdg:interact}}\;
        \eIf{\ell($\mathbf{s}^*$) $\neq$ \ell($\mathbf{s}_1$) $\land$ \ell($\mathbf{s}^*$) $<$ $\epsilon_n$}{
            $\mathbf{s}_1$, $\mathbf{s}_2$ \gets~ $\mathbf{s}^*$, $\mathbf{x}_r$\;
            \If{\ell($\mathbf{x}_r$) $=$ $0$}{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
                \textbf{break}\;
            }
        }{
            \eIf{\ell($\mathbf{s}^*$) $\neq$ $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$
            }{
                \app{$\mathbf{G}$, $\mathbf{s}^*$}
            }
            \uIf{\ell($\mathbf{x}_r$) $>$ $1$}{
                $\mathbf{s}_1$ \gets~ $\mathbf{x}_r$[:$1$]\;
                $\mathbf{x}_r$ \gets~ $\mathbf{x}_r$[$1$:]\;
                $\mathbf{s}_2$ \gets~ $\mathbf{x}_r$\;
            }
            \ElseIf{\ell($\mathbf{x}_r$) $=$ $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{x}_r$\;
                \textbf{break}\;
            }
        }
    }
    \While{\ell($\mathbf{a}$) $>$ $\epsilon_s$}{
        \app{$\mathbf{G}$, $\mathbf{a}$[:$\epsilon_s$]}\;
        $\mathbf{a}$ \gets~ $\mathbf{a}$[$\epsilon_s$:]\;
    }
    \lIf{\ell($\mathbf{a}$) $>$ $0$}{
        \app{$\mathbf{G}$, $\mathbf{a}$}
    }
    \Return $\mathbf{G}$\;
    }

    \caption{Algoritem RDG3~\cite{alg:rdg3} za dekompozicijo problema.}
    \label{pcode:rdg3}
\end{algorithm}

% TODO opiši algoritem RDG3
% TODO dodaj primerjavo med RDG2--RDG3

\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{erdg}{ERDG}
    \SetKwFunction{Inter}{Interact2}
    \SetKwFunction{app}{Pripni}

    \Fn{\erdg{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\alpha$, $k$}}{
    $\mathbf{a}$, $\mathbf{G}$ \gets~ [], []\;
    $\mathbf{x}_{l,l}$, $y_{l,l}$ \gets~ $\mathbf{b}_{l}$, $f(\mathbf{b}_{l})$\;
    $\mathbf{s}_1$, $\mathbf{s}_2$ \gets~ [1], [\lFor*{$i=2$ \KwTo \ell($\mathbf{b}_{l}$)}{$i$}]\;
    \While{\ell($\mathbf{s}_2$) > $0$}{
        $\mathbf{x}_{u,l}$ \gets~ $\mathbf{x}_{l,l}$\;
        $\mathbf{x}_{u,l}$[$\mathbf{s}_1$] \gets~ $\mathbf{b}_{l}$[$\mathbf{s}_1$]\;
        $y_{u,l}$ \gets~ $f(\mathbf{x}_{u,l})$\;
        $\mathbf{s}^*$ \gets~ \Inter{$f$, $\mathbf{x}_{l, l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{x}_2$, [$y_{l,l}$, $-y_{u,l}$, $\infty$, $\infty$]}\tcp*[f]{Algoritem~\ref{pcode:erdg:interact}}\;
        \eIf{\ell($\mathbf{s}^*$) = \ell($\mathbf{s}_1$)}{
            \eIf{\ell($\mathbf{s}_1$) = $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$[:$1$]\;
            }{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
            }
            $\mathbf{s}_1$ \gets~ $\mathbf{s}_2$[:$1$]\;
            $\mathbf{s}_2$ \gets~ $\mathbf{s}_2$[$1$:]\;
        }{
            $\mathbf{s}_1$ \gets~ $\mathbf{s}^*$\;
            $\mathbf{s}_2$ \gets~ [\lForEach*{$e$ in $\mathbf{s}_2$}{\lIf*{$e$ not in $\mathbf{s}_1$}{$e$}}]\;
        }
        \If{\ell($\mathbf{s}_2$) = $0$}{
            \uIf{\ell($\mathbf{s}_1$) > $1$}{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
            }
            \ElseIf{\ell($\mathbf{s}_1$) = $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$\;
            }
        }
    }
    \ForEach{$e$ in $\mathbf{a}$}{
        \app{$\mathbf{G}$, $e$}\;
    }
    \Return $\mathbf{G}$\;
    }

    \caption{Algoritem ERDG~\cite{alg:erdg} za dekompozicijo problema.}
    \label{pcode:erdg}
\end{algorithm}

\begin{algorithm}
    \DontPrintSemicolon
	\SetKwFunction{Inter}{Interact2}
    \SetKwFunction{floor}{floor}

	\Fn{\Inter{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\mathbf{y}$}}{
    $s$, $\mathbf{s}$ \gets~ \textbf{True}, $\mathbf{s}_1$\;
    \If{$\infty$ in $\mathbf{y}$}{
        $\mathbf{x}_{l,m}$, $\mathbf{x}_{u,m}$ \gets~ $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$\;
        $\mathbf{x}_{l,m}$, $\mathbf{x}_{u,m}$ \gets~ $\frac{\mathbf{b}_{l} + \mathbf{b}_{u}}{2}$[$\mathbf{s}_2$], $\frac{\mathbf{b}_{l} + \mathbf{b}_{u}}{2}$[$\mathbf{s}_2$]\;
        $\mathbf{y}$[$3$], $\mathbf{y}$[$4$] \gets~ $-f(\mathbf{x}_{l,m})$, $f(\mathbf{x}_{u,m})$\;
        \If{$|\sum{\mathbf{y}}|$ $\leqslant$ $\epsilon$}{
            $s$ \gets~ \textbf{False}\;
        }
    }
    \If{$s$}{
        \eIf{\ell($\mathbf{s}_2$) = $1$}{
            $\mathbf{s}$ \gets~ $\mathbf{s}_1 \cup \mathbf{s}_2$\;
        }{
            $k$ \gets~ \floor{\ell($\mathbf{s}_2$) / $2$}\;
            $\mathbf{g}_1$, $\mathbf{g}_2$ \gets~ $\mathbf{s}_2$[:$k$], $\mathbf{s}_2$[$k$:]\;
            $\mathbf{x}_1$, $\mathbf{y}_n$ \gets~ \Inter{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_1$, [$\mathbf{y}$[1], $\mathbf{y}$[2], $\infty$, $\infty$]}\tcp*[f]{Algoritem~\ref{pcode:erdg:interact}}\;
            \eIf{$\sum{\mathbf{y}} - \sum{\mathbf{y}_n}$ $\neq$ $0$}{
                \eIf{\ell($\mathbf{x}_1$) = \ell($\mathbf{s}_1$)}{
                    $\mathbf{x}_2$, \_ \gets~ \Inter{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_2$, $\mathbf{y}$}\tcp*[f]{Algoritem~\ref{pcode:erdg:interact}}\;
                }{
                    $\mathbf{x}_2$, \_ \gets~ \Inter{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_2$, [$\mathbf{y}$[1], $\mathbf{y}$[2], $\infty$, $\infty$]}\tcp*[f]{Algoritem~\ref{pcode:erdg:interact}}\;
                }
                $\mathbf{s}$ \gets~ $\mathbf{x}_1 \cup \mathbf{x}_2$\;
            }{
                $\mathbf{s}$ \gets~ $\mathbf{x}_1$\;
            }
        }
    }
    \Return{$\mathbf{s}$, $\mathbf{y}$}\;
    }
     
	\caption{Funkcija \texttt{Interact2} za detekcijo interakcije med komponentami pri algoritmu ERDG.}
	\label{pcode:erdg:interact}
\end{algorithm}

% TODO opiši algoritem ERDG
% TODO dodaj primerjavo med RDG3--ERDG

\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{trdg}{TRDG}
    \SetKwFunction{group}{Group}
    \SetKwFunction{app}{Pripni}

    \Fn{\trdg{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\alpha$, $k$}}{
    $\epsilon$ \gets~ $\alpha \cdot \min \left( |f(\mathbf{x}_1)|, \cdots, \left|f \left(\mathbf{x}_{\frac{k}{4}} \right) \right| \right)$\;
    $\mathbf{a}$, $\mathbf{G}$ \gets~ [], []\;
    $\mathbf{x}_{l,l}$, $y_{l,l}$ \gets~ $\mathbf{b}_{l}$, $f(\mathbf{b}_{u})$\;
    $\mathbf{s}_1$, $\mathbf{s}_2$ \gets~ [1], [\lFor*{$i=2$ \KwTo \ell($\mathbf{b}_{l}$)}{$i$}]\;
    \While{\ell($\mathbf{s}_2$) > 0}{
        $\mathbf{x}_{u,l}$ \gets~ $\mathbf{x}_{l,l}$\;
        $\mathbf{x}_{u,l}$[$\mathbf{s}_1$] \gets~ $\mathbf{b}_{u}$[$\mathbf{s}_1$]\;
        $y_{u,l}$ \gets~ $f(\mathbf{x}_{u,l})$\;
        $\mathbf{s}^*$ \gets~ \group{$f$, $\mathbf{x}_{l, l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\epsilon$, $y_{l,l} - y_{u,l}$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
        \eIf{\ell($\mathbf{s}^*$) = \ell($\mathbf{s}_1$)}{
            \eIf{\ell($\mathbf{s}_1$) = $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$[:$1$]\;
            }{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
            }
            $\mathbf{s}_1$ \gets~ $\mathbf{s}_2$[:$1$]\;
            $\mathbf{s}_2$ \gets~ $\mathbf{s}_2$[$1$:]\;
        }{
            $\mathbf{s}_1$ \gets~ $\mathbf{s}^*$\;
            $\mathbf{s}_2$ \gets~ [\lForEach*{$e$ in $\mathbf{s}_2$}{\lIf*{$e$ not in $\mathbf{s}_1$}{$e$}}]\;
        }
        \If{\ell($\mathbf{s}_2$) = $0$}{
            \uIf{\ell($\mathbf{s}_1$) > 1}{
                \app{$\mathbf{G}$, $\mathbf{s}_1$}\;
            }
            \ElseIf{\ell($\mathbf{s}_1$) = $1$}{
                $\mathbf{a}$ \gets~ $\mathbf{a} \cup \mathbf{s}_1$\;
            }
        }
    }
    \ForEach{$e$ in $\mathbf{a}$}{
        \app{$\mathbf{G}$, $e$}\;
    }
    \Return $\mathbf{G}$\;
    }

    \caption{Algoritem TRDG~\cite{alg:trdg} za dekompozicijo problema.}
    \label{pcode:trdg}
\end{algorithm}

\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{Inter}{Interact3}


	\Fn{\Inter{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_2$, $\epsilon$, $\delta$}}{
    $\mathbf{x}_{l,m}$, $\mathbf{x}_{u,m}$ \gets~ $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$\;
    $\mathbf{x}_{l,m}$, $\mathbf{x}_{u,m}$ \gets~ $\frac{\mathbf{b}_{l} + \mathbf{b}_{u}}{2}$[$\mathbf{s}_2$], $\frac{\mathbf{b}_{l} + \mathbf{b}_{u}}{2}$[$\mathbf{s}_2$]\;
    $y_{l,m}$, $y_{u,m}$ \gets~ $f(\mathbf{x}_{l,m})$, $f(\mathbf{x}_{u,m})$\;
    \eIf{$|\delta - (y_{l,m} - y_{u,m})|$ > $\epsilon$}{
        \Return{\textbf{True}}\;
    }{
        \Return{\textbf{False}}\;
    }
    }

	\caption{Funkcija \texttt{Interact3} za detekcijo interakcije med komponentami.}
	\label{pcode:trdg:interact}
\end{algorithm}

\begin{algorithm}
    \DontPrintSemicolon
    \SetKwFunction{group}{Group}
    \SetKwFunction{Inter}{Interact3}
    \SetKwFunction{floor}{floor}
    \SetKwFunction{app}{Pripni}

	\Fn{\group{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{s}_2$, $\epsilon$, $\delta$}}{
    $\mathbf{s}^*$ \gets~ $\mathbf{s}_1$\;
    \If(\tcc*[f]{Algoritem~\ref{pcode:trdg:interact}}){\Inter{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_2$, $\epsilon$, $\delta$}}{
        \uIf{\ell($\mathbf{s}_2$) = $1$}{
            $\mathbf{s}^*$ \gets~ $\mathbf{s}_1 \cup \mathbf{s}_2$\;
        }
        \uElseIf{\ell($\mathbf{s}_2$) = $2$}{
            $\mathbf{g}_1$, $\mathbf{g}_2$ \gets~ $\mathbf{s}_2$[:$1$], $\mathbf{s}_2$[$1$:]\;
            $\mathbf{x}_1$ \gets~ \group{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_1$, $\epsilon$, $\delta$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
            $\mathbf{x}_2$ \gets~ \group{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_2$, $\epsilon$, $\delta$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
            $\mathbf{s}^*$ \gets~ $\mathbf{x}_1 \cup \mathbf{x}_2$\;
        }
        \Else{
            $k$ \gets~ \floor{\ell($\mathbf{s}_2$) / $3$}\;
            $\mathbf{g}_1$, $\mathbf{g}_2$, $\mathbf{g}_3$ \gets~ $\mathbf{s}_2$[:$k$], $\mathbf{s}_2$[$k$:$2 k$], $\mathbf{s}_2$[:$2 k$]\;
            $\mathbf{x}_1$ \gets~ \group{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_1$, $\epsilon$, $\delta$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
            $\mathbf{x}_2$ \gets~ \group{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_2$, $\epsilon$, $\delta$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
            $\mathbf{x}_3$ \gets~ \group{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$, $\mathbf{x}_{l,l}$, $\mathbf{x}_{u,l}$, $\mathbf{s}_1$, $\mathbf{g}_3$, $\epsilon$, $\delta$}\tcp*[f]{Algoritem~\ref{pcode:trdg:group}}\;
            $\mathbf{s}^*$ \gets~ $\mathbf{x}_1 \cup \mathbf{x}_2 \cup \mathbf{x}_3$\;
        }
    }
    \Return{$\mathbf{s}^*$}\;
    }

	\caption{Funkcija \texttt{Group} za grupiranje komponent pri algoritmu TRDG.}
	\label{pcode:trdg:group}
\end{algorithm}

% TODO opiši algoritem TRDG
% TODO dodaj primerjavo med ERDG--TRDG

\section{Omejitve sorodnih del}

% TODO

\chapter{Koevolucijski algoritem rojev delcev}\label{chap:algo}

V trenutnem teku razvoja raziskav na področju strojnega učenja in podobnih domen, je opaziti različne tehnike zmanjševanja težavnosti kompleksnosti problema.
Uporabljena sta dva glavna pristopa.
Prva tehnika je ekstrakcija ključnih podatkov iz velike količine podatkov.
Druga tehnika je redukcija dimenzionalnosti vhodnih podatkov oziroma iskanje pomembnih pomembnih značilnic v podatkih, ki je ena izmed bolj uporabljenih tehnik redukcije kompleksnosti učenja napovedovalnega modela. 
Učni modeli z veliko dimenzionalnostjo rabijo veliko časa za učenje, zaradi velikega iskalnega prostora optimalnih parametrov napovedovalnega modela, ter v mnogih primerih ne vsebujejo najbolj kvalitetnega znanja o problemu, za katerega so bili učeni~\cite{bib:si_machine_learning_bad_model}.

\begin{equation}
    \min_{\mathbf{x}}{f(\mathbf{x})} = \left( \min_{\mathbf{x_1}}{f(x_1,\cdots)}, \cdots , \min_{\mathbf{x_m}}{f(\cdots, x_m)} \right)
\end{equation}

% TODO

\begin{algorithm}
    \DontPrintSemicolon
	\SetKwFunction{ccalgo}{CCPSO}
	\SetKwFunction{run}{Generacija}
	\SetKwFunction{Decom}{Dekompozicija}
	\SetKwFunction{appbetter}{Posodobi}

    \Fn{\ccalgo{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$}}{
	$\mathbf{g}$ \gets~ \Decom{$f$, $\mathbf{b}_{l}$, $\mathbf{b}_{u}$}\;
	$\mathbf{a}$ \gets~ [\lForEach*{$g$ in $\mathbf{g}$}{Inicializirja začetno populacijo algoritma $a$ na podlagi grupe $g$}]\;
    $\mathbf{X^*}$, $\mathbf{y}^*$ \gets~ Pridobi najboljše posameznike vsake grupe\;
	%$\mathbf{x^*}$, $y^*$ \gets~ Get best individual and fitness value from $\mathbf{X^*}$\;
	$\mathbf{x^*}$, $y^*$ \gets~ Najdi najboljšega posameznika iz $\mathbf{X^*}$\;
	\While{$\neg$ zaustavitveni pogoj zadovoljen}{
		\ForEach{$i$, $a$ in $\mathbf{a}$}{
			$\mathbf{x_n^*}$, $y_n^*$ \gets~ \run{$a$}\;
			\If{$y_n^* < \mathbf{y^*}[i]$}{
				$\mathbf{X^*}[i]$, $\mathbf{y^*}[i]$ \gets~ $\mathbf{x_n^*}$, $y_n^*$\;
				\If{$y_n^* < y^*$}{
                    $\mathbf{x^*}$, $y^*$ \gets~ $\mathbf{x_n^*}$, $y_n^*$
                }
			}
		}
        \If{Katera od grup našla novo lokalno najboljšo rešitev}{
		    \ForEach{$g$ in $\mathbf{g}$}{
                $\mathbf{x_n}[g]$ \gets~ $\mathbf{X^*}[g]$
            }
		    $y_n$ \gets~ $f(\mathbf{x_n})$\;
		    \If{$y_n < y^*$}{
                $\mathbf{x^*}$, $y^*$ = $\mathbf{x_n}$, $y_n$
            }
        }
	}
	\Return{$\mathbf{x^*}$, $y^*$}\;
    }

	\caption{Predlagan koevolucijski algoritem.}
	\label{pcode:ccalgo}
\end{algorithm}

\chapter{Eksperiment}\label{chap:exp}

% TODO

\begin{table}[t]
    \renewcommand{\arraystretch}{1.3}
    \centering
    \caption{Število grup in čas izvajanja za testne funkcije CEC2013lsgo.} \label{tab:bech:func_basic_stats}
    \begin{tabular}{|c|c|c|c|}
        \hline
        Funkcija & Število grup & Število neodvisnih spremenljivk & Čas izvajanja ($s$) \\\hline
        $f_1$    & $0$  & $1000$ & $262{,}588$ \\\hline
        $f_2$    & $0$  & $1000$ & $331{,}273$ \\\hline
        $f_3$    & $0$  & $1000$ & $547{,}029$ \\\hline
        $f_4$    & $8$  & $0$    & $466{,}366$ \\\hline
        $f_5$    & $8$  & $0$    & $634{,}510$ \\\hline
        $f_6$    & $8$  & $0$    & $739{,}836$ \\\hline
        $f_7$    & $8$  & $0$    & $186{,}057$ \\\hline
        $f_8$    & $20$ & $0$    & $620{,}498$ \\\hline
        $f_9$    & $20$ & $0$    & $802{,}833$ \\\hline
        $f_{10}$ & $20$ & $0$    & $786{,}904$ \\\hline
        $f_{11}$ & $20$ & $0$    & $602{,}630$ \\\hline
        $f_{12}$ & $0$  & $1000$ & $73{,}145$  \\\hline
        $f_{13}$ & $20$ & $0$    & $546{,}250$ \\\hline
        $f_{14}$ & $20$ & $0$    & $622{,}586$ \\\hline
        $f_{15}$ & $0$  & $1000$ & $386{,}074$ \\\hline
    \end{tabular}
\end{table}

\begin{table}[t]
    \renewcommand{\arraystretch}{1.3}
    \centering
    \caption{Velikosti grup za testne funkcije CEC2013lsgo, ki imajo več skupin.} \label{tab:bech:func_basic_stats_groups_no}
    \begin{tabular}{|c|c|c|c|}
        \hline
        Funkcija & Velikosti grup \\\hline
        $f_4$    & $50, 25, 25, 100, 50, 25, 25, 700$ \\\hline
        $f_5$    & $50, 25, 25, 100, 50, 25, 25, 700$ \\\hline
        $f_6$    & $50, 25, 25, 100, 50, 25, 25, 700$ \\\hline
        $f_7$    & $50, 25, 25, 100, 50, 25, 25, 700$ \\\hline
        $f_8$    & $50, 50, 25, 25, 100, 100, 25, 25, 50, 25, 100, 25, 100, 50, 25, 25, 25, 100, 50, 25$ \\\hline
        $f_9$    & $50, 50, 25, 25, 100, 100, 25, 25, 50, 25, 100, 25, 100, 50, 25, 25, 25, 100, 50, 25$ \\\hline
        $f_{10}$ & $50, 50, 25, 25, 100, 100, 25, 25, 50, 25, 100, 25, 100, 50, 25, 25, 25, 100, 50, 25$ \\\hline
        $f_{11}$ & $50, 50, 25, 25, 100, 100, 25, 25, 50, 25, 100, 25, 100, 50, 25, 25, 25, 100, 50, 25$ \\\hline
        $f_{13}$ & $50, 50, 25, 25, 100, 100, 25, 25, 50, 25, 100, 25, 100, 50, 25, 25, 25, 100, 50, 25$ \\\hline
        $f_{14}$ & $50, 50, 25, 25, 100, 100, 25, 25, 50, 25, 100, 25, 100, 50, 25, 25, 25, 100, 50, 25$ \\\hline
    \end{tabular}
\end{table}


% TODO

\section{Primerjava uporabe metod RDG}

% TODO

\begin{table}[t]
    \renewcommand{\arraystretch}{1.3}
    \centering
    \caption{Vrednosti parametrov metod za grupiranje.} \label{tab:algs:group_params}
    \begin{tabular}{|c|c|}
        \hline
        Algoritem & Vrednosti parametrov \\\hline
        RDG & $\alpha = 1\mathrm{e}{-12}$, $k = 10$ \\\hline
        RDG2 & $\alpha = 1\mathrm{e}{-12}$ \\\hline
        RDG3 & $\alpha = 1\mathrm{e}{-12}$, $\epsilon_n = 50$, $\epsilon_s = 100$ \\\hline
        ERDG & $\alpha = 1\mathrm{e}{-12}$ \\\hline
        TRDG & $\alpha = 1\mathrm{e}{-12}$, $k = 10$ \\\hline
    \end{tabular}
\end{table}

% TODO dodaj podatek zakaj si uporabil take vrednosti parametrov
% Večina vrednosti parametrov sem pridobil iz literature o teh algorithmih, saj so pri vsaki raziskavi izvedli tudi analizo parametrov za naš izbrani problem CEC2013

\subsection{Analiza rezultatov}

% TODO

\section{Primerjava PSO algoritmov z metodami RDG}

% TODO

\subsection{Analiza rezultatov}

% TODO

\chapter{Zaključek}\label{chap:end}

% TODO
